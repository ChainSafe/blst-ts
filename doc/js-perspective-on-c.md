# A JS Developer's Perspective on `C/C++`

## What JS Developers Take For Granted

JS has some serious luxuries. The runtime is forgiving because it is a single threaded, event driven, garbage collected language. The language is forgiving because it is dynamically typed and interpreted. All of that is a function of lines of code in `node`, `v8`, `libuv` and a host of other factors including good design and decent language semantics.

When building native code, those things need to be done manually. Memory will need to be managed.  Threading context will need to be understood. This is not to say that it is impossible to write good code in `C/C++` but it is a lot more to think about than writing JS.

As an example, async in JS can be confusing for new developers. Some docs and blogs were written very early and use patterns like callbacks. Some are from much later and use async generators. Along with structural changes, there have also been stylistic shifts over time. This same thing happened in `C/C++`.

The differences that are seen across docs/blogs/etc stem from `C` being quite old and lots of patterns changed along the way.  Another piece is that `C` and `C++` are very similar, but they are not the same.  Much like `TS` is an extension of `JS`, `C++` is an extension of `C`.  So like `JS/TS` there are `C` and `C++` ways to do things, and in many contexts both ways are "valid."

## Memory Management

Stack and heap allocation are both similar and different to JS and it is important to understand the nuances because they have greatly influenced this library.  In  particular, focus on how everything gets freed.  It's easy to allocate memory but tracking and cleaning up the allocations is where the challenge lies.  Many of the paradigms in `C/C++` are inherently, or explicitly, implemented for resource management.  Because this library is primarily `c++` we will use [RAII](https://en.cppreference.com/w/cpp/language/raii) and OOP to help us along the way.

On of the big things I noticed in my journey to native code is, in general, it is much easier to deal with stack allocated objects.  Working with the heap is harder and error prone so the docs real like horror novels. Its all a bit frightening. Stack allocation is much more natural as it mimics JS but there are a few sticky wickets to pay attention to.

First is that not everything can be stack allocated (see the discussion about [`blst::Pairing`](./blst.md#initialization-of-blstpairing) for a got-ya).  There was another thing that caught me by surprise but intuitively makes sense once I thought about it.  Stack overflow is real and arrays have lots of stuff in them.  In native code there is the possibility that user data may be bigger than the stack can hold.  I know... This is intuitive... But in JS those are things we don't really think about so it wasn't second nature yet. This is a real and dangerous risk.

Another big piece is that in `C`, all functions are pass AND return by value.  Full stop.  It is possible to pass references and pointers yes, but those are both first class citizens that get passed by value. The whole premise behind creating the references/pointers is that the "value" associated is much smaller so the copy operation is faster.  In generally a pointer is the same size as the system bytes (ie. 32-bit systems have 4 byte memory addresses and 64-bit systems have 8 byte memory addresses) and references depend on both system and compiler specifics.  Complex objects on the other hand can get VERY large.

While the solution to most efficiency problems will be passing by ref or pointer, the specifics of how to allocate and return need to be well understood to avoid segfault.  For the rest of this tutorial we will reference the following class:

```c++
class SomethingFancy {
    SomethingFancy(int &value) {}
};
```

## Compiler-Generated Functions

Compiler-Generated functions are code that gets auto-generated by the compiler to ease the overhead of OOP and reduce the verbosity of `C++` code, among other benefits.  They are also something that can [bite hard](./debugging.md#debugging-by-example).

`C++` was built to organize large code-bases by creating objects that encapsulate data with the functional behavior.  This helps to organize stuff but lends to complex semantics to get around creating, destroying and moving complex objects. Move semantics is a great example. Not only are they complex but they are pure `C++` and represent a huge efficiency boost to keep the data throughput as high as `C`. The following are the move constructor and move-assignment operators for `SomethingFancy`:

```c++
SomethingFancy::SomethingFancy(SomethingFancy &&other);
SomethingFancy &SomethingFancy::operator=(SomethingFancy &&other);
```

Just knowing that those exist and that they are NOT compiler generated is two pieces of information that do not fit into either the `C` or `JS` mental model.

The following lines are NOT The same...

```c++
SomethingFancy a;
SomethingFancy b{42};
SomethingFancy c = SomethingFancy{123};
```

SomethingFancy 'a' is allocated and constructed using the "default constructor" and in this instance that is a "magic function" that is compiler created. 'b' is allocated and created in-place using the declared constructor as would be expected. 'c' is... complex. The compiler-created default constructor is being used to allocate memory at 'c' and a right-hand reference is created using the declared constructor.  Then the compiler-created destructor deletes the temporary at 'c' leaving an empty allocation, and then the value in the right-hand reference is copied to the allocation at 'c' using the compiler-created "magic" copy assignment operator.  Lots and lots of confusing compiler slight-of-hand.

While this is not intended to be a full tutorial these idea were something that definitely took getting used to and those "magic" functions are very hard to debug.  I would also like to make note that the above example is strictly a `c++` thing.  `SomethingFancy` is not a built in type and constructor syntax with an initializer list are not `c`, they are '`c++`'.  The ideas of right-hand reference, operator overloading and constructor/destructors are all "`++`" too.

```c
int a;
int b{42}; // not valid c, but is valid c++
int c = 42;
```

It is valid, and often times required, to allocate memory but to no initialize it.  In JS the uninitialized value is `undefined` in `c` using an uninitialized variable is "undefined behavior".  

With `c` as the context 'a' is uninitialized and can be dangerous. 'b' is invalid syntax and 'c' is an integer initialized to 42.

With `c++` as the context 'a' is treated the same as raw `c`. 'b' is an integer initialized to 42 using constructor syntax. 'c' is an integer initialized to 42 using assignment syntax.

## Passing To and Returning From Functions

Building functions happen for the same reasons in c as they do in JS.  They help to ease the mental burden for "what something does".  The differences in memory allocation drive very different coding paradigms though.

In modern JS we generally pass in what is needed inside the function context, return back the values that result and if an error occurs it is thrown.  That pattern generally holds true for both sync an async functions.

`C` stack-allocation semantics, and the resulting variable scoping, often result in a pattern where both input and output arguments are passed and then the function either returns `void` or `int` (to denote the error code where `0` represents no error) to show if valid execution occurred.  Generally one sees variables allocated for both inputs and return(s) in the calling context and then those variables are passed into the function.  Many times the function call is placed in a conditional to check execution status.

```c
KZGSettings settings; // this is the output of load_trusted_setup_file()
FILE *file_handle = fopen(******, "r"); // this is the input of load_trusted_setup_file()
C_KZG_RET ret = load_trusted_setup_file(&settings, file_handle);

if (fclose(file_handle) != 0) {
    if (ret == C_KZG_OK) {
        free_trusted_setup(&(data->settings));
    }
}

if (ret != C_KZG_OK) {
    return 1;
}

return 0;
```

There is one more paradigm that is worth explicitly stating.  Note in this example that `fclose` is in the conditional and `load_trusted_setup_file` is not.  `load_trusted_setup_file` is a function where the return value needs to be handled for either valid or invalid execution (ie valid but if fclose fails need to `free_trusted_setup` and for invalid execution the function returns `1`).  `fclose` however only requires that invalid execution requires further work.

There are a few challenges that emerge from the way that `c` functions are structured.  In very large code-bases its very difficult to track allocations and de-allocations because they do not always occur in the same functions.

In `c++` everything from above is true and there are some additional paradigms that should be presented.  Object have higher complexity for initialization/clean-up and bigger sizes.  Those "enhancements" and the `class` paradigm are where most of the complexity in `c++` (relative to `c`) comes in.  The trade of for the complexity is RAII.  Or i suppose RAII emerged because of the complexity and it is a very nice paradigm for large and complex systems.

RAII helps to overcome a lot of the challenges that emerge with allocations and de-allocations that occur in different locations in the codebase.  Most of the "magic" that happens in `c++` is the compiler filling in "defaults" so that the class structure isn't overly verbose.  It is not necessary to write functions for constructors, destructors, copy semantics nor move semantics.  They get "auto" generated for us, sometime with disastrous consequences.

The "rule of 3" and "rule of 5" were created to crystalize the mental paradigm so that developers do not get bitten by the magic/helpers that get induced.

## Closing Thoughts

It is simple to go watch some coding tutorials, like I did, and whip out a ton of code "that works".  Where most c/c++ code tutorials lack is this kind of stuff.  Best-practices.  Coding paradigms.  Relational anecdotes to paradigms I already understood...  The stuff that a senior dev would lean over and tell us Juniors if we still had a water cooler to talk by...

If you too have had a hard-fought win while learning system-level programming as a JS dev, this is the place to share that red badge of courage.
